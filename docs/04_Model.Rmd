---
title: APSA Model Building
author: Gannon and Kent
output: html_document
---

# Steps

1. Load ISAF Data
2. Descriptive statistics
3. Models
  3a. Why contribute amount of troops?
  3b. Does it pay off?

# Data loading

```{R}
isaf <- rio::import('data/iiss_afghan_complete.rds')
## Remove afghanistan because it is not a realistic self-contributor
## Remove US because paper is about relations with the US
isaf <- dplyr::filter(isaf, stateabb != "AFG" & stateabb != "USA")
## Only focus on years 2001-2005
isaf <- dplyr::filter(isaf, year <= 2005)
## Somehow still duplicates, fix later...
isaf <- isaf[!duplicated(isaf[c("ccode", "year")]),]
```

## Descriptive statistics

First, let's take a look at our DV and how it varies across key variables:

```{R}
## need to import ggplot, gets messy as ggplot2::ggplot()
library(ggplot2)
## points cluster by country, so fairly noisy
ggplot(isaf, aes(x = degree, y = troops_afghan_ratio)) + geom_point() +
      geom_text(aes(label=stateabb),hjust=0, vjust=0, size = 2)

## New dataset which averages across contributions and predictors
countries <- unique(isaf$stateabb)
isaf_avg <- dplyr::tibble(country = as.character(),
                      avg_contr = as.numeric(),
                      degree = as.integer(),
                      ideal_point = as.numeric(),
                      eigen = as.numeric(),
                      sequiv = as.integer())

## Loop to fill in average country contributions
for(i in 1:length(countries)){
  abb <- countries[i]
  ## subset on country
  temp <- dplyr::filter(isaf, stateabb == abb)
  ## store country name
  isaf_avg[i,1] <- as.character(abb)
  ## average contr
  isaf_avg[i,2] <- sum(temp$troops_afghan_ratio)/nrow(temp)
  ## average degree
  isaf_avg[i,3] <- sum(temp$degree)/nrow(temp)
  ## average ideal_point
  isaf_avg[i,4] <- sum(temp$abs_ideal_diff)/nrow(temp)
  ## average eigenvector centrality
  isaf_avg[i,5] <- sum(temp$eigen)/nrow(temp)
  ## average structural equivalence
  isaf_avg[i,6] <- sum(temp$sequiv)/nrow(temp)
}

ggplot(isaf_avg, aes(x = sequiv, y = avg_contr)) + geom_point() +
      geom_text(aes(label=country),hjust=0, vjust=0, size = 2) +
      geom_smooth()

## Remove Canada for curvilinear plot, but not analysis
isaf_avg_sub <- dplyr::filter(isaf_avg, country != "CAN")

## Now our curvilinear plot without Canada
## Remove non-contributor labels to avoid mess
contr_plot <- ggplot(isaf_avg_sub, aes(x = sequiv, y = avg_contr, label = country)) +
      geom_point(size = 2) +
      ggrepel::geom_text_repel(size = 3.5,
                      segment.color = 'transparent',
                      data = subset(isaf_avg_sub, avg_contr > 0)) +
      geom_smooth(level = 0.95) + theme_classic() +
      labs(title = "Average Troop Contributions by Structural Equivalence with the U.S.",
          x = "Alliance Network Structural Equivalence with the U.S.",
          y = "Average Ratio of Troops Contributed Relative to Total Troops")
## Ok, we are off.
ggsave('paper/figures/contributions.png')
```

## Network visual

```{R}
load("data/alliance_networks.RData")
require(network)
isaf_alliance_nets <- x

## Troop data
isaf2 <- rio::import('data/iiss_afghan_complete.rds')
## Remove afghanistan because it is not a realistic self-contributor
se <- sna::sedist(isaf_alliance_nets[[2]], method = "correlation")
## contributions
isaf02 <- dplyr::filter(isaf2, year == 2002)
isaf02 <- dplyr::select(isaf02, c(stateabb, troops_afghan_ratio))
countries <- network::get.vertex.attribute(isaf_alliance_nets[[2]], "vertex.names")
countries <- data.frame(countries)
colnames(countries) <- c("stateabb")
troop_contr <- dplyr::left_join(countries, isaf02)
set.vertex.attribute(isaf_alliance_nets[[2]], "contributions", troop_contr$troops_afghan_ratio)
contributions <- get.vertex.attribute(isaf_alliance_nets[[2]], "contributions")

plot(isaf_alliance_nets[[2]], displaylabels = TRUE,
    label=network.vertex.names(isaf_alliance_nets[[1]]),
    displayisolates = TRUE, label.cex = 0.75,
    #vertex.cex=200*contributions,label.cex=0.75,
     edge.col=rgb(150,150,150,100,maxColorValue=255),
     label.pos=5,vertex.col="lightblue")

plot(isaf_alliance_nets[[1]])
## https://www.jessesadler.com/post/network-analysis-with-r/

library(tidygraph)
library(ggraph)

allynet <- intergraph::asIgraph(isaf_alliance_nets[[2]])
ally_igraph_tidy <- as_tbl_graph(allynet)
## Not a bad idea to the extent that it gives us control over
## size and color based on variables...
## We can build in casualties and centrality here...
ggraph(ally_igraph_tidy) +
    geom_edge_link() +
    geom_node_point() +
    geom_node_text(aes(label = vertex.names), repel = TRUE) +
    labs() +
    theme_graph()
```

# Model Estimation

A polynomial equation does not fit the data well and GAMs introduce interpretation barriers that may not be necessary. An easy fix seems to be fitting two separate models, representing two steps:
1) who contributes at all?
2) among contributors, what predicts the log of contributions?

## Who contributes at all?

```{R}
## Who contributes at all?
isaf$contributor <- 0
for(i in 1:nrow(isaf)){
  if(isaf[i,6] > 0){ ## if troops provided > 0
    isaf[i,44] <- 1 ## make contributor 1
  }
}

## plot contributor vs non contributor

## Network only
model1 <- glm(contributor ~ sequiv + abs_ideal_diff + degree,
              family = binomial(link = "logit"), data = isaf)
summary(model1)

## Network FE
model2 <- plm::plm(contributor ~ sequiv + abs_ideal_diff + degree,
              family = binomial(link = "logit"),
               index = c("year", "country"), data = isaf)
summary(model2)


## Network and controls
model3 <- glm(contributor ~ sequiv + abs_ideal_diff + degree + dem + distance,
              family = binomial(link = "logit"), data = isaf)
summary(model3)

## Network and controls, FE
model4 <- plm::plm(contributor ~ sequiv + abs_ideal_diff + degree + dem + distance,
              family = binomial(link = "logit"),
              index = c("year", "country"), data = isaf)
summary(model4)


library(dotwhisker)
library(dplyr)

## Coefficient plot
dwplot(list(model1, model2, model3, model4), dodge_size = 0.2) %>%
  relabel_predictors(c(sequiv = "Structural Equivalence",
                         abs_ideal_diff = "Ideal Point Distance",
                         degree = "Network Degrees",
                         dem = "Democracy",
                         distance = "Distance")) +
  theme_classic() +
  xlab("Coefficient Estimate") +
  geom_vline(xintercept = 0, colour = "grey60", linetype = 2) +
  scale_colour_hue(name = "Models",
                     labels = c("Network Only", "Network Only, FE", "Full Model", "Full Model, FE")) +
  labs(title = "Logistic Regression Estimates of Decision to Commit Troops")

ggsave('paper/figures/logit_coef.png')

## Predicted probability of committing troops by absolute point ideal diff
## Note ideology predicts whether or not to contribute best.
## Much less uncertainty than sequiv, which visuals show.

## https://stackoverflow.com/questions/39783358/ggplot2-and-glm-plot-a-predicted-probability
logit_plot <- ggplot(isaf, aes(x = abs_ideal_diff, y = contributor)) +
    geom_point() +
  stat_smooth(method="glm", method.args=list(family="binomial"), se=TRUE) +
  labs(x ="Distance from U.S. Ideal Point",
  y ="Probability of Committing Troops",
  title ="Probability of Committing Troops by Ideological Distance from the U.S.") +
  theme_classic()
ggsave('paper/figures/logit.png')

```

## How much do they contribute?

```{R}
## Model 2: How many troops do contributors provide?
isaf_contributors <- dplyr::filter(isaf, troops_afghan_total > 0)

## Note logging contributions gives us a linear relationship
## Make sure to transform for predicted contributions plots
## In contributors, NZL is an outlier, mostly is structural equivalence
## Democracies contribute more, but sequiv does not go away...
ggplot(isaf_contributors, aes(x = sequiv, y = log(troops_afghan_ratio))) +
  geom_point() + geom_smooth(method="glm", family=gaussian,
            formula=y ~ x,
            alpha=0.2, size=2) +
  theme_classic()



model5 <- glm(log(troops_afghan_ratio) ~ sequiv + abs_ideal_diff + degree,
              data = isaf_contributors)
broom::tidy(model5)

model6 <- plm::plm(log(troops_afghan_ratio) ~ sequiv + abs_ideal_diff + degree,
                index = c("year", "country"), data = isaf_contributors)
summary(model6)


model7 <- glm(log(troops_afghan_ratio) ~ sequiv + abs_ideal_diff + degree + dem + distance,
              data = isaf_contributors)
broom::tidy(model7)

## No difference
model8 <- plm::plm(log(troops_afghan_ratio) ~ sequiv + abs_ideal_diff + degree + dem + distance,
                  index = c("year", "country"), data = isaf_contributors)
summary(model8)

## Structural equivalence is robust here... So once committint, it is strongly aligned allies.

dwplot(list(model5, model6, model7, model8), dodge_size = 0.2) %>%
  relabel_predictors(c(sequiv = "Structural Equivalence",
                         abs_ideal_diff = "Ideal Point Distance",
                         degree = "Network Degrees",
                         dem = "Democracy",
                         distance = "Distance")) +
  theme_classic() +
  xlab("Coefficient Estimate") +
  geom_vline(xintercept = 0, colour = "grey60", linetype = 2) +
  scale_colour_hue(name = "Models",
                     labels = c("Network Only", "Network Only, FE", "Full Model", "Full Model, FE")) +
  labs(title = "Linear Regression Estimates of Amount of Troops Committed")

ggsave('paper/figures/linear_coef.png')
```
