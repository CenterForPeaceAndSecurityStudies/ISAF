---
title: APSA Model Building
author: Gannon and Kent
output: html_document
---

# Steps

1. Load ISAF Data
2. Descriptive statistics
3. Models
  3a. Why contribute amount of troops?
  3b. Does it pay off?

# Data loading

```{R}
isaf <- rio::import('data/iiss_afghan_complete.rds')
## Remove afghanistan because it is not a realistic self-contributor
## Remove US because paper is about relations with the US
isaf <- dplyr::filter(isaf, stateabb != "AFG" & stateabb != "USA")
## Only focus on years 2001-2005
isaf <- dplyr::filter(isaf, year <= 2005)
## Are there duplicates?? Yes, from building this dataset too many times?
## Let's remove... We can fix later.
isaf <- isaf[!duplicated(isaf[,1:2]),]
```

## Descriptive statistics

First, let's take a look at our DV and how it varies across key variables:

```{R}
## points cluster by country, so fairly noisy
ggplot(isaf, aes(x = degree, y = troops_afghan_ratio)) + geom_point() +
      geom_text(aes(label=stateabb),hjust=0, vjust=0, size = 2)

## New dataset which averages across contributions and predictors
countries <- unique(isaf$stateabb)
isaf_avg <- dplyr::tibble(country = as.character(),
                      avg_contr = as.numeric(),
                      degree = as.integer(),
                      ideal_point = as.numeric(),
                      eigen = as.numeric(),
                      sequiv = as.integer())

## Loop to fill in average country contributions
for(i in 1:length(countries)){
  abb <- countries[i]
  ## subset on country
  temp <- dplyr::filter(isaf, stateabb == abb)
  ## store country name
  isaf_avg[i,1] <- as.character(abb)
  ## average contr
  isaf_avg[i,2] <- sum(temp$troops_afghan_ratio)/nrow(temp)
  ## average degree
  isaf_avg[i,3] <- sum(temp$degree)/nrow(temp)
  ## average ideal_point
  isaf_avg[i,4] <- sum(temp$abs_ideal_diff)/nrow(temp)
  ## average eigenvector centrality
  isaf_avg[i,5] <- sum(temp$eigen)/nrow(temp)
  ## average structural equivalence
  isaf_avg[i,6] <- sum(temp$sequiv)/nrow(temp)
}

## Better -- reverse x-axis because it measures distance in terms of structural equiv
## That way, states are more similar to the US as we get further along the x-axis
## ggplot does work well with ggplot::ggplot()
require(ggplot2)
ggplot(isaf_avg, aes(x = sequiv, y = avg_contr)) + geom_point() +
      geom_text(aes(label=country),hjust=0, vjust=0, size = 2) +
      geom_smooth()

## Remove Canada for curvilinear plot, but not analysis
isaf_avg_sub <- dplyr::filter(isaf_avg, country != "CAN")

## Now our curvilinear plot without Canada
## Remove non-contributor labels to avoid mess
ggplot(isaf_avg_sub, aes(x = sequiv, y = avg_contr, label = country)) +
      geom_point(size = 2) +
      ggrepel::geom_text_repel(size = 3.5,
                      segment.color = 'transparent',
                      data = subset(isaf_avg_sub, avg_contr > 0)) +
      geom_smooth(level = 0.95) + scale_x_reverse() + theme_classic() +
      labs(title = "Average Troop Contributions by Structural Equivalence with the U.S.",
          x = "Alliance Network Structural Equivalence with the U.S.",
          y = "Average Ratio of Troops Contributed Relative to Total Troops")
## Ok, we are off.

```

# Model Estimation

A polynomial equation does not fit the data well and GAMs introduce interpretation barriers that may not be necessary. An easy fix seems to be fitting two separate models, representing two steps:
1) who contributes at all?
2) among contributors, what predicts the log of contributions?

```{R}
## Who contributes at all?
isaf$contributor <- 0
for(i in 1:nrow(isaf)){
  if(isaf[i,6] > 0){
    isaf[i,40] <- 1
  }
}

##
model1 <- glm(contributor ~ sequiv + abs_ideal_diff,
              family = binomial(link = "logit"), data = isaf)
summary(model1)

## Makes no difference in estimate, so let's use this for plotting easily
model2 <- glm(contributor ~ sequiv,
              family = binomial(link = "logit"), data = isaf)
summary(model2)

## Predicted probability of committing troops by structural equivalence
ggplot(isaf, aes(x = sequiv, y = contributor)) +
  stat_smooth(method="glm", family=binomial,
            formula=y ~ x,
            alpha=0.2, size=2) +
  scale_x_reverse() +
  labs(x ="Alliance Network Structural Equivalence with the U.S.",
  y ="Probability of Committing Troops",
  title ="Probability of Committing Troops by Structural Equivalence with the U.S.") +
  theme_classic()


## Model 2: How many troops do contributors provide?
isaf_contributors <- dplyr::filter(isaf, troops_afghan_total > 0)

## Note logging contributions gives us a linear relationship
## Make sure to transform for predicted contributions plots
ggplot(isaf_contributors, aes(x = sequiv, y = log(troops_afghan_ratio))) +
  geom_point() + geom_smooth(method="glm", family=gaussian,
            formula=y ~ x,
            alpha=0.2, size=2) +
  scale_x_reverse() +
  theme_classic()


model3 <- glm(log(troops_afghan_ratio) ~ sequiv + abs_ideal_diff, data = isaf_contributors)
broom::tidy(model3)

model4 <- plm::plm(log(troops_afghan_ratio) ~ sequiv + abs_ideal_diff,
                  index = c("year", "country"), data = isaf_contributors)
summary(model4)


## With additional network statistics -- sequiv capture US similarity,
## but clustercoef and degree capture extent to which a state is embedded in alliance network
model5 <- glm(log(troops_afghan_ratio) ~ sequiv + abs_ideal_diff +
              clustercoef + degree, data = isaf_contributors)
broom::tidy(model5)

## Fixed effects
model6 <- plm::plm(log(troops_afghan_ratio) ~ sequiv + abs_ideal_diff +
                  clustercoef + degree,
                  index = c("year", "country"), data = isaf_contributors)

require(dotwhisker)
## Ideal point data inferences vary by model specification, but structural equiv does not...
dwplot(list(model3, model4, model5, model6)) %>%
                             relabel_predictors(c(sequiv = "Tie Differences",
                                    abs_ideal_diff = "Ideal Point Difference",
                                    clustercoef = "Embeddedness",
                                    degree = "Degree")) +
                  theme_bw() +
                  labs(title =
                  "Troop Contributions by U.S. Tie Strength and Network Centrality"
                  ) +
                  scale_color_manual(values = c("#000000", "#E69F00", "#56B4E9", "#009E73"),
                  labels = c("U.S. Tie Strength", "U.S. Tie Strength, FE",
                  "U.S. Tie Strength and Network Centrality",
                  "U.S. Tie Strength and Network Centrality, FE"))
```

How best to measure 'tie strength'?

```{R}
## network statistics and troop contr
ggplot(isaf, aes(x = clustercoef, y = troops_afghan_ratio)) +
    geom_point() + geom_smooth()

ggplot(isaf, aes(x = degree, y = troops_afghan_ratio)) +
    geom_point() + geom_smooth()

ggplot(isaf, aes(x = eigen, y = troops_afghan_ratio)) +
    geom_point() + geom_smooth()

ggplot(isaf, aes(x = sequiv, y = troops_afghan_ratio)) +
    geom_point() + geom_smooth()

ggplot(isaf, aes(x = abs_ideal_diff, y = troops_afghan_ratio)) +
    geom_point() +
    geom_smooth() +
    coord_cartesian(xlim = c(0,3))

## create a variable that captures ideology and degree. Maybe degree/ideology.
## That way the further the distance ideologically, the smaller the number?
isaf$test <- isaf$degree/isaf$abs_ideal_diff

ggplot(isaf, aes(x = test, y = isaf$troops_afghan_ratio)) +
    geom_point() + geom_smooth()

## What about subsetting on contributors?
isaf_sub <- dplyr::filter(isaf, troops_afghan_ratio > 0)
isaf_sub$test <- isaf_sub$degree/isaf_sub$abs_ideal_diff
ggplot(isaf_sub, aes(x = degree, y = troops_afghan_ratio)) +
    geom_point() + geom_smooth()

ggplot(isaf_sub, aes(x = abs_ideal_diff, y = troops_afghan_ratio)) +
    geom_point() + geom_smooth()


ggplot(isaf_sub, aes(x = test, y = troops_afghan_ratio)) +
    geom_point() + geom_smooth()
```

## Extra code -- delete after html_document

```{R}

fit <- glm(troops_afghan_ratio ~ abs_ideal_diff + sequiv + I(sequiv^2), data = isaf)


fit <- glm(avg_contr ~ ideal_point + sequiv + I(sequiv^2),
            data = isaf_avg_sub)
# fit <- glm(troops_afghan_ratio ~ abs_ideal_diff + sequiv, data = isaf)
summary(fit)

## predicted values, let's use fake data covering the range of sequiv 0:152
prd <- data.frame(sequiv = seq(from = min(isaf_avg_sub$sequiv, na.rm = TRUE),
                              to = max(isaf_avg_sub$sequiv, na.rm = TRUE),
                              by = 0.5),
                  ideal_point = mean(isaf_avg_sub$ideal_point, na.rm = TRUE))
err <- predict(fit, newdata = prd, se.fit = TRUE)

prd$lci <- err$fit - 1.96 * err$se.fit
prd$fit <- err$fit
prd$uci <- err$fit + 1.96 * err$se.fit


ggplot(prd, aes(x = sequiv, y = fit)) +
  theme_bw() +
  geom_line() +
  geom_smooth(aes(ymin = lci, ymax = uci), stat = "identity") +
  geom_point(data = isaf_avg_sub, aes(x = sequiv, y = avg_contr)) +
  scale_x_reverse()


## One thought, what if we weighted sequiv by ideal point? I.e. mult by?
## Because smaller structural eq distance means more similar and
## smaller ideal dist is good, the smaller the product, then the closer.

isaf_avg_sub$weighted_sim <- isaf_avg_sub$sequiv*isaf_avg_sub$ideal_point
ggplot(isaf_avg_sub, aes(x = weighted_sim, y = avg_contr)) + geom_point() +
      geom_text(aes(label=country),hjust=0, vjust=0, size = 4) +
      geom_smooth() + scale_x_reverse()

fit2 <- glm(avg_contr ~ weighted_sim + I(weighted_sim^2),
            data = isaf_avg_sub)
# fit <- glm(troops_afghan_ratio ~ abs_ideal_diff + sequiv, data = isaf)
summary(fit2)

## predicted values, let's use fake data covering the range of sequiv 0:152
prd2 <- data.frame(weighted_sim = seq(from = min(isaf_avg_sub$weighted_sim, na.rm = TRUE),
                              to = max(isaf_avg_sub$weighted_sim, na.rm = TRUE),
                              by = 0.5))
err2 <- predict(fit2, newdata = prd2, se.fit = TRUE)

prd2$lci <- err2$fit - 1.96 * err2$se.fit
prd2$fit <- err2$fit
prd2$uci <- err2$fit + 1.96 * err2$se.fit


ggplot(prd2, aes(x = weighted_sim, y = fit)) +
  theme_bw() +
  geom_line() +
  geom_smooth(aes(ymin = lci, ymax = uci), stat = "identity") +
  geom_point(data = isaf_avg_sub, aes(x = weighted_sim, y = avg_contr)) +
  scale_x_reverse()

## So we can see that the fit is funky with just a polynomial regression...
## Instead we need something more flexible (gam)

gam1 <- mgcv::gam(troops_afghan_ratio ~ s(sequiv) + s(abs_ideal_diff),
                  method = "REML", data = isaf)
```
